// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for oracledbreceiver metrics.
type MetricsSettings struct {
	OracledbCPUTime               MetricSettings `mapstructure:"oracledb.cpu_time"`
	OracledbEnqueueDeadlocks      MetricSettings `mapstructure:"oracledb.enqueue_deadlocks"`
	OracledbEnqueueLocksLimit     MetricSettings `mapstructure:"oracledb.enqueue_locks.limit"`
	OracledbEnqueueLocksUsage     MetricSettings `mapstructure:"oracledb.enqueue_locks.usage"`
	OracledbEnqueueResourcesLimit MetricSettings `mapstructure:"oracledb.enqueue_resources.limit"`
	OracledbEnqueueResourcesUsage MetricSettings `mapstructure:"oracledb.enqueue_resources.usage"`
	OracledbExchangeDeadlocks     MetricSettings `mapstructure:"oracledb.exchange_deadlocks"`
	OracledbExecuteCount          MetricSettings `mapstructure:"oracledb.execute_count"`
	OracledbHardParses            MetricSettings `mapstructure:"oracledb.hard_parses"`
	OracledbLogicalReads          MetricSettings `mapstructure:"oracledb.logical_reads"`
	OracledbParseCountTotal       MetricSettings `mapstructure:"oracledb.parse_count_total"`
	OracledbPgaMemory             MetricSettings `mapstructure:"oracledb.pga_memory"`
	OracledbPhysicalReads         MetricSettings `mapstructure:"oracledb.physical_reads"`
	OracledbProcessLimit          MetricSettings `mapstructure:"oracledb.process.limit"`
	OracledbProcessUsage          MetricSettings `mapstructure:"oracledb.process.usage"`
	OracledbSessionLimit          MetricSettings `mapstructure:"oracledb.session.limit"`
	OracledbSessionUsage          MetricSettings `mapstructure:"oracledb.session.usage"`
	OracledbTablespaceLimit       MetricSettings `mapstructure:"oracledb.tablespace.limit"`
	OracledbTablespaceUsage       MetricSettings `mapstructure:"oracledb.tablespace.usage"`
	OracledbUserCommits           MetricSettings `mapstructure:"oracledb.user_commits"`
	OracledbUserRollbacks         MetricSettings `mapstructure:"oracledb.user_rollbacks"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		OracledbCPUTime: MetricSettings{
			Enabled: true,
		},
		OracledbEnqueueDeadlocks: MetricSettings{
			Enabled: true,
		},
		OracledbEnqueueLocksLimit: MetricSettings{
			Enabled: true,
		},
		OracledbEnqueueLocksUsage: MetricSettings{
			Enabled: true,
		},
		OracledbEnqueueResourcesLimit: MetricSettings{
			Enabled: true,
		},
		OracledbEnqueueResourcesUsage: MetricSettings{
			Enabled: true,
		},
		OracledbExchangeDeadlocks: MetricSettings{
			Enabled: true,
		},
		OracledbExecuteCount: MetricSettings{
			Enabled: true,
		},
		OracledbHardParses: MetricSettings{
			Enabled: true,
		},
		OracledbLogicalReads: MetricSettings{
			Enabled: true,
		},
		OracledbParseCountTotal: MetricSettings{
			Enabled: true,
		},
		OracledbPgaMemory: MetricSettings{
			Enabled: true,
		},
		OracledbPhysicalReads: MetricSettings{
			Enabled: true,
		},
		OracledbProcessLimit: MetricSettings{
			Enabled: true,
		},
		OracledbProcessUsage: MetricSettings{
			Enabled: true,
		},
		OracledbSessionLimit: MetricSettings{
			Enabled: true,
		},
		OracledbSessionUsage: MetricSettings{
			Enabled: true,
		},
		OracledbTablespaceLimit: MetricSettings{
			Enabled: true,
		},
		OracledbTablespaceUsage: MetricSettings{
			Enabled: true,
		},
		OracledbUserCommits: MetricSettings{
			Enabled: true,
		},
		OracledbUserRollbacks: MetricSettings{
			Enabled: true,
		},
	}
}

type metricOracledbCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.cpu_time metric with initial data.
func (m *metricOracledbCPUTime) init() {
	m.data.SetName("oracledb.cpu_time")
	m.data.SetDescription("Cumulative CPU time, in seconds")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbCPUTime(settings MetricSettings) metricOracledbCPUTime {
	m := metricOracledbCPUTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbEnqueueDeadlocks struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.enqueue_deadlocks metric with initial data.
func (m *metricOracledbEnqueueDeadlocks) init() {
	m.data.SetName("oracledb.enqueue_deadlocks")
	m.data.SetDescription("Total number of deadlocks between table or row locks in different sessions.")
	m.data.SetUnit("{deadlocks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbEnqueueDeadlocks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbEnqueueDeadlocks) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbEnqueueDeadlocks) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbEnqueueDeadlocks(settings MetricSettings) metricOracledbEnqueueDeadlocks {
	m := metricOracledbEnqueueDeadlocks{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbEnqueueLocksLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.enqueue_locks.limit metric with initial data.
func (m *metricOracledbEnqueueLocksLimit) init() {
	m.data.SetName("oracledb.enqueue_locks.limit")
	m.data.SetDescription("Maximum limit of active enqueue locks.")
	m.data.SetUnit("{locks}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbEnqueueLocksLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbEnqueueLocksLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbEnqueueLocksLimit) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbEnqueueLocksLimit(settings MetricSettings) metricOracledbEnqueueLocksLimit {
	m := metricOracledbEnqueueLocksLimit{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbEnqueueLocksUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.enqueue_locks.usage metric with initial data.
func (m *metricOracledbEnqueueLocksUsage) init() {
	m.data.SetName("oracledb.enqueue_locks.usage")
	m.data.SetDescription("Current count of active enqueue locks.")
	m.data.SetUnit("{locks}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbEnqueueLocksUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbEnqueueLocksUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbEnqueueLocksUsage) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbEnqueueLocksUsage(settings MetricSettings) metricOracledbEnqueueLocksUsage {
	m := metricOracledbEnqueueLocksUsage{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbEnqueueResourcesLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.enqueue_resources.limit metric with initial data.
func (m *metricOracledbEnqueueResourcesLimit) init() {
	m.data.SetName("oracledb.enqueue_resources.limit")
	m.data.SetDescription("Maximum limit of active enqueue resources.")
	m.data.SetUnit("{resources}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbEnqueueResourcesLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbEnqueueResourcesLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbEnqueueResourcesLimit) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbEnqueueResourcesLimit(settings MetricSettings) metricOracledbEnqueueResourcesLimit {
	m := metricOracledbEnqueueResourcesLimit{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbEnqueueResourcesUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.enqueue_resources.usage metric with initial data.
func (m *metricOracledbEnqueueResourcesUsage) init() {
	m.data.SetName("oracledb.enqueue_resources.usage")
	m.data.SetDescription("Current count of active enqueue resources.")
	m.data.SetUnit("{resources}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbEnqueueResourcesUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbEnqueueResourcesUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbEnqueueResourcesUsage) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbEnqueueResourcesUsage(settings MetricSettings) metricOracledbEnqueueResourcesUsage {
	m := metricOracledbEnqueueResourcesUsage{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbExchangeDeadlocks struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.exchange_deadlocks metric with initial data.
func (m *metricOracledbExchangeDeadlocks) init() {
	m.data.SetName("oracledb.exchange_deadlocks")
	m.data.SetDescription("Number of times that a process detected a potential deadlock when exchanging two buffers and raised an internal, restartable error. Index scans are the only operations that perform exchanges.")
	m.data.SetUnit("{deadlocks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbExchangeDeadlocks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbExchangeDeadlocks) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbExchangeDeadlocks) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbExchangeDeadlocks(settings MetricSettings) metricOracledbExchangeDeadlocks {
	m := metricOracledbExchangeDeadlocks{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbExecuteCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.execute_count metric with initial data.
func (m *metricOracledbExecuteCount) init() {
	m.data.SetName("oracledb.execute_count")
	m.data.SetDescription("Total number of calls (user and recursive) that executed SQL statements")
	m.data.SetUnit("{executions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbExecuteCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbExecuteCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbExecuteCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbExecuteCount(settings MetricSettings) metricOracledbExecuteCount {
	m := metricOracledbExecuteCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbHardParses struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.hard_parses metric with initial data.
func (m *metricOracledbHardParses) init() {
	m.data.SetName("oracledb.hard_parses")
	m.data.SetDescription("Number of hard parses")
	m.data.SetUnit("{parses}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbHardParses) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbHardParses) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbHardParses) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbHardParses(settings MetricSettings) metricOracledbHardParses {
	m := metricOracledbHardParses{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbLogicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.logical_reads metric with initial data.
func (m *metricOracledbLogicalReads) init() {
	m.data.SetName("oracledb.logical_reads")
	m.data.SetDescription("Number of logical reads")
	m.data.SetUnit("{reads}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbLogicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbLogicalReads) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbLogicalReads) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbLogicalReads(settings MetricSettings) metricOracledbLogicalReads {
	m := metricOracledbLogicalReads{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbParseCountTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.parse_count_total metric with initial data.
func (m *metricOracledbParseCountTotal) init() {
	m.data.SetName("oracledb.parse_count_total")
	m.data.SetDescription("Total number of parse calls.")
	m.data.SetUnit("{parses}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbParseCountTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbParseCountTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbParseCountTotal) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbParseCountTotal(settings MetricSettings) metricOracledbParseCountTotal {
	m := metricOracledbParseCountTotal{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbPgaMemory struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.pga_memory metric with initial data.
func (m *metricOracledbPgaMemory) init() {
	m.data.SetName("oracledb.pga_memory")
	m.data.SetDescription("Session PGA (Program Global Area) memory")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbPgaMemory) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbPgaMemory) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbPgaMemory) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbPgaMemory(settings MetricSettings) metricOracledbPgaMemory {
	m := metricOracledbPgaMemory{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbPhysicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.physical_reads metric with initial data.
func (m *metricOracledbPhysicalReads) init() {
	m.data.SetName("oracledb.physical_reads")
	m.data.SetDescription("Number of physical reads")
	m.data.SetUnit("{reads}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbPhysicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbPhysicalReads) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbPhysicalReads) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbPhysicalReads(settings MetricSettings) metricOracledbPhysicalReads {
	m := metricOracledbPhysicalReads{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbProcessLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.process.limit metric with initial data.
func (m *metricOracledbProcessLimit) init() {
	m.data.SetName("oracledb.process.limit")
	m.data.SetDescription("Maximum limit of active processes.")
	m.data.SetUnit("{processes}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbProcessLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbProcessLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbProcessLimit) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbProcessLimit(settings MetricSettings) metricOracledbProcessLimit {
	m := metricOracledbProcessLimit{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbProcessUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.process.usage metric with initial data.
func (m *metricOracledbProcessUsage) init() {
	m.data.SetName("oracledb.process.usage")
	m.data.SetDescription("Current count of active processes.")
	m.data.SetUnit("{processes}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbProcessUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbProcessUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbProcessUsage) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbProcessUsage(settings MetricSettings) metricOracledbProcessUsage {
	m := metricOracledbProcessUsage{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.limit metric with initial data.
func (m *metricOracledbSessionLimit) init() {
	m.data.SetName("oracledb.session.limit")
	m.data.SetDescription("Maximum limit of active sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbSessionLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionLimit) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionLimit(settings MetricSettings) metricOracledbSessionLimit {
	m := metricOracledbSessionLimit{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.usage metric with initial data.
func (m *metricOracledbSessionUsage) init() {
	m.data.SetName("oracledb.session.usage")
	m.data.SetDescription("Count of active sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbSessionUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbOracleSessionTypeAttributeValue string, dbOracleSessionStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.oracle.session.type", dbOracleSessionTypeAttributeValue)
	dp.Attributes().PutStr("db.oracle.session.status", dbOracleSessionStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionUsage) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionUsage(settings MetricSettings) metricOracledbSessionUsage {
	m := metricOracledbSessionUsage{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbTablespaceLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.tablespace.limit metric with initial data.
func (m *metricOracledbTablespaceLimit) init() {
	m.data.SetName("oracledb.tablespace.limit")
	m.data.SetDescription("Maximum size of tablespace in bytes.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbTablespaceLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbOracleTablespaceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.oracle.tablespace.name", dbOracleTablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbTablespaceLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbTablespaceLimit) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbTablespaceLimit(settings MetricSettings) metricOracledbTablespaceLimit {
	m := metricOracledbTablespaceLimit{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbTablespaceUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.tablespace.usage metric with initial data.
func (m *metricOracledbTablespaceUsage) init() {
	m.data.SetName("oracledb.tablespace.usage")
	m.data.SetDescription("Used tablespace in bytes.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbTablespaceUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbOracleTablespaceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.oracle.tablespace.name", dbOracleTablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbTablespaceUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbTablespaceUsage) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbTablespaceUsage(settings MetricSettings) metricOracledbTablespaceUsage {
	m := metricOracledbTablespaceUsage{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbUserCommits struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.user_commits metric with initial data.
func (m *metricOracledbUserCommits) init() {
	m.data.SetName("oracledb.user_commits")
	m.data.SetDescription("Number of user commits. When a user commits a transaction, the redo generated that reflects the changes made to database blocks must be written to disk. Commits often represent the closest thing to a user transaction rate.")
	m.data.SetUnit("{commits}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbUserCommits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbUserCommits) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbUserCommits) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbUserCommits(settings MetricSettings) metricOracledbUserCommits {
	m := metricOracledbUserCommits{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbUserRollbacks struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.user_rollbacks metric with initial data.
func (m *metricOracledbUserRollbacks) init() {
	m.data.SetName("oracledb.user_rollbacks")
	m.data.SetDescription("Number of times users manually issue the ROLLBACK statement or an error occurs during a user's transactions")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbUserRollbacks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbUserRollbacks) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbUserRollbacks) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbUserRollbacks(settings MetricSettings) metricOracledbUserRollbacks {
	m := metricOracledbUserRollbacks{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                           pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity                     int                 // maximum observed number of metrics per resource.
	resourceCapacity                    int                 // maximum observed number of resource attributes.
	metricsBuffer                       pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                           component.BuildInfo // contains version information
	metricOracledbCPUTime               metricOracledbCPUTime
	metricOracledbEnqueueDeadlocks      metricOracledbEnqueueDeadlocks
	metricOracledbEnqueueLocksLimit     metricOracledbEnqueueLocksLimit
	metricOracledbEnqueueLocksUsage     metricOracledbEnqueueLocksUsage
	metricOracledbEnqueueResourcesLimit metricOracledbEnqueueResourcesLimit
	metricOracledbEnqueueResourcesUsage metricOracledbEnqueueResourcesUsage
	metricOracledbExchangeDeadlocks     metricOracledbExchangeDeadlocks
	metricOracledbExecuteCount          metricOracledbExecuteCount
	metricOracledbHardParses            metricOracledbHardParses
	metricOracledbLogicalReads          metricOracledbLogicalReads
	metricOracledbParseCountTotal       metricOracledbParseCountTotal
	metricOracledbPgaMemory             metricOracledbPgaMemory
	metricOracledbPhysicalReads         metricOracledbPhysicalReads
	metricOracledbProcessLimit          metricOracledbProcessLimit
	metricOracledbProcessUsage          metricOracledbProcessUsage
	metricOracledbSessionLimit          metricOracledbSessionLimit
	metricOracledbSessionUsage          metricOracledbSessionUsage
	metricOracledbTablespaceLimit       metricOracledbTablespaceLimit
	metricOracledbTablespaceUsage       metricOracledbTablespaceUsage
	metricOracledbUserCommits           metricOracledbUserCommits
	metricOracledbUserRollbacks         metricOracledbUserRollbacks
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, buildInfo component.BuildInfo, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                           pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                       pmetric.NewMetrics(),
		buildInfo:                           buildInfo,
		metricOracledbCPUTime:               newMetricOracledbCPUTime(settings.OracledbCPUTime),
		metricOracledbEnqueueDeadlocks:      newMetricOracledbEnqueueDeadlocks(settings.OracledbEnqueueDeadlocks),
		metricOracledbEnqueueLocksLimit:     newMetricOracledbEnqueueLocksLimit(settings.OracledbEnqueueLocksLimit),
		metricOracledbEnqueueLocksUsage:     newMetricOracledbEnqueueLocksUsage(settings.OracledbEnqueueLocksUsage),
		metricOracledbEnqueueResourcesLimit: newMetricOracledbEnqueueResourcesLimit(settings.OracledbEnqueueResourcesLimit),
		metricOracledbEnqueueResourcesUsage: newMetricOracledbEnqueueResourcesUsage(settings.OracledbEnqueueResourcesUsage),
		metricOracledbExchangeDeadlocks:     newMetricOracledbExchangeDeadlocks(settings.OracledbExchangeDeadlocks),
		metricOracledbExecuteCount:          newMetricOracledbExecuteCount(settings.OracledbExecuteCount),
		metricOracledbHardParses:            newMetricOracledbHardParses(settings.OracledbHardParses),
		metricOracledbLogicalReads:          newMetricOracledbLogicalReads(settings.OracledbLogicalReads),
		metricOracledbParseCountTotal:       newMetricOracledbParseCountTotal(settings.OracledbParseCountTotal),
		metricOracledbPgaMemory:             newMetricOracledbPgaMemory(settings.OracledbPgaMemory),
		metricOracledbPhysicalReads:         newMetricOracledbPhysicalReads(settings.OracledbPhysicalReads),
		metricOracledbProcessLimit:          newMetricOracledbProcessLimit(settings.OracledbProcessLimit),
		metricOracledbProcessUsage:          newMetricOracledbProcessUsage(settings.OracledbProcessUsage),
		metricOracledbSessionLimit:          newMetricOracledbSessionLimit(settings.OracledbSessionLimit),
		metricOracledbSessionUsage:          newMetricOracledbSessionUsage(settings.OracledbSessionUsage),
		metricOracledbTablespaceLimit:       newMetricOracledbTablespaceLimit(settings.OracledbTablespaceLimit),
		metricOracledbTablespaceUsage:       newMetricOracledbTablespaceUsage(settings.OracledbTablespaceUsage),
		metricOracledbUserCommits:           newMetricOracledbUserCommits(settings.OracledbUserCommits),
		metricOracledbUserRollbacks:         newMetricOracledbUserRollbacks(settings.OracledbUserRollbacks),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(pmetric.ResourceMetrics)

// WithDbOracleInstanceName sets provided value as "db.oracle.instance.name" attribute for current resource.
func WithDbOracleInstanceName(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().PutStr("db.oracle.instance.name", val)
	}
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/oracledbreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricOracledbCPUTime.emit(ils.Metrics())
	mb.metricOracledbEnqueueDeadlocks.emit(ils.Metrics())
	mb.metricOracledbEnqueueLocksLimit.emit(ils.Metrics())
	mb.metricOracledbEnqueueLocksUsage.emit(ils.Metrics())
	mb.metricOracledbEnqueueResourcesLimit.emit(ils.Metrics())
	mb.metricOracledbEnqueueResourcesUsage.emit(ils.Metrics())
	mb.metricOracledbExchangeDeadlocks.emit(ils.Metrics())
	mb.metricOracledbExecuteCount.emit(ils.Metrics())
	mb.metricOracledbHardParses.emit(ils.Metrics())
	mb.metricOracledbLogicalReads.emit(ils.Metrics())
	mb.metricOracledbParseCountTotal.emit(ils.Metrics())
	mb.metricOracledbPgaMemory.emit(ils.Metrics())
	mb.metricOracledbPhysicalReads.emit(ils.Metrics())
	mb.metricOracledbProcessLimit.emit(ils.Metrics())
	mb.metricOracledbProcessUsage.emit(ils.Metrics())
	mb.metricOracledbSessionLimit.emit(ils.Metrics())
	mb.metricOracledbSessionUsage.emit(ils.Metrics())
	mb.metricOracledbTablespaceLimit.emit(ils.Metrics())
	mb.metricOracledbTablespaceUsage.emit(ils.Metrics())
	mb.metricOracledbUserCommits.emit(ils.Metrics())
	mb.metricOracledbUserRollbacks.emit(ils.Metrics())
	for _, op := range rmo {
		op(rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := pmetric.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordOracledbCPUTimeDataPoint adds a data point to oracledb.cpu_time metric.
func (mb *MetricsBuilder) RecordOracledbCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricOracledbCPUTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbEnqueueDeadlocksDataPoint adds a data point to oracledb.enqueue_deadlocks metric.
func (mb *MetricsBuilder) RecordOracledbEnqueueDeadlocksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbEnqueueDeadlocks.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbEnqueueLocksLimitDataPoint adds a data point to oracledb.enqueue_locks.limit metric.
func (mb *MetricsBuilder) RecordOracledbEnqueueLocksLimitDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbEnqueueLocksLimit.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbEnqueueLocksUsageDataPoint adds a data point to oracledb.enqueue_locks.usage metric.
func (mb *MetricsBuilder) RecordOracledbEnqueueLocksUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbEnqueueLocksUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbEnqueueResourcesLimitDataPoint adds a data point to oracledb.enqueue_resources.limit metric.
func (mb *MetricsBuilder) RecordOracledbEnqueueResourcesLimitDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbEnqueueResourcesLimit.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbEnqueueResourcesUsageDataPoint adds a data point to oracledb.enqueue_resources.usage metric.
func (mb *MetricsBuilder) RecordOracledbEnqueueResourcesUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbEnqueueResourcesUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbExchangeDeadlocksDataPoint adds a data point to oracledb.exchange_deadlocks metric.
func (mb *MetricsBuilder) RecordOracledbExchangeDeadlocksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbExchangeDeadlocks.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbExecuteCountDataPoint adds a data point to oracledb.execute_count metric.
func (mb *MetricsBuilder) RecordOracledbExecuteCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbExecuteCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbHardParsesDataPoint adds a data point to oracledb.hard_parses metric.
func (mb *MetricsBuilder) RecordOracledbHardParsesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbHardParses.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbLogicalReadsDataPoint adds a data point to oracledb.logical_reads metric.
func (mb *MetricsBuilder) RecordOracledbLogicalReadsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbLogicalReads.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbParseCountTotalDataPoint adds a data point to oracledb.parse_count_total metric.
func (mb *MetricsBuilder) RecordOracledbParseCountTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbParseCountTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbPgaMemoryDataPoint adds a data point to oracledb.pga_memory metric.
func (mb *MetricsBuilder) RecordOracledbPgaMemoryDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbPgaMemory.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbPhysicalReadsDataPoint adds a data point to oracledb.physical_reads metric.
func (mb *MetricsBuilder) RecordOracledbPhysicalReadsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbPhysicalReads.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbProcessLimitDataPoint adds a data point to oracledb.process.limit metric.
func (mb *MetricsBuilder) RecordOracledbProcessLimitDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbProcessLimit.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbProcessUsageDataPoint adds a data point to oracledb.process.usage metric.
func (mb *MetricsBuilder) RecordOracledbProcessUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbProcessUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionLimitDataPoint adds a data point to oracledb.session.limit metric.
func (mb *MetricsBuilder) RecordOracledbSessionLimitDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionLimit.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionUsageDataPoint adds a data point to oracledb.session.usage metric.
func (mb *MetricsBuilder) RecordOracledbSessionUsageDataPoint(ts pcommon.Timestamp, val int64, dbOracleSessionTypeAttributeValue string, dbOracleSessionStatusAttributeValue string) {
	mb.metricOracledbSessionUsage.recordDataPoint(mb.startTime, ts, val, dbOracleSessionTypeAttributeValue, dbOracleSessionStatusAttributeValue)
}

// RecordOracledbTablespaceLimitDataPoint adds a data point to oracledb.tablespace.limit metric.
func (mb *MetricsBuilder) RecordOracledbTablespaceLimitDataPoint(ts pcommon.Timestamp, val int64, dbOracleTablespaceNameAttributeValue string) {
	mb.metricOracledbTablespaceLimit.recordDataPoint(mb.startTime, ts, val, dbOracleTablespaceNameAttributeValue)
}

// RecordOracledbTablespaceUsageDataPoint adds a data point to oracledb.tablespace.usage metric.
func (mb *MetricsBuilder) RecordOracledbTablespaceUsageDataPoint(ts pcommon.Timestamp, val int64, dbOracleTablespaceNameAttributeValue string) {
	mb.metricOracledbTablespaceUsage.recordDataPoint(mb.startTime, ts, val, dbOracleTablespaceNameAttributeValue)
}

// RecordOracledbUserCommitsDataPoint adds a data point to oracledb.user_commits metric.
func (mb *MetricsBuilder) RecordOracledbUserCommitsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbUserCommits.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbUserRollbacksDataPoint adds a data point to oracledb.user_rollbacks metric.
func (mb *MetricsBuilder) RecordOracledbUserRollbacksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbUserRollbacks.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
